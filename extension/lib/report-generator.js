/**
 * ReportGenerator - Generates downloadable reports from interview session data
 */
import { supabaseREST } from './supabase-config.js';

export class ReportGenerator {
    constructor() {
        this.supabase = supabaseREST;
    }

    /**
     * Generate a Markdown report for a specific session
     * @param {string} sessionId - The ID of the session
     * @returns {Promise<string>} - The Markdown content
     */
    async generateSessionReport(sessionId) {
        try {
            console.log('[ReportGenerator] Generating report for session:', sessionId);

            // 1. Fetch all sync messages for this session (transcript, hints, etc.)
            // We select directly from sync_messages table
            const messages = await this.supabase.select(
                'sync_messages', 
                `session_id=eq.${sessionId}&order=created_at.asc`
            );

            if (!messages || messages.length === 0) {
                return '# Interview Session Report\n\nNo data found for this session.';
            }

            // 2. Fetch session details for header
            // Try to find the session metadata (start time, etc.) from the first message or a separate query if needed.
            // For now, we'll assume the session exists if messages exist.
            const sessionDate = new Date(messages[0].created_at).toLocaleDateString();
            const sessionTime = new Date(messages[0].created_at).toLocaleTimeString();

            // 3. Build Markdown content
            let md = `# Interview Session Report\n`;
            md += `**Date:** ${sessionDate} ${sessionTime}\n`;
            md += `**Session ID:** ${sessionId}\n\n`;
            md += `---\n\n`;

            md += `## Transcript & AI Insights\n\n`;

            // Group messages by type or just flow chronologically
            // We want to interleave Transcript and AI Hints to show context
            
            // Format: 
            // > **User:** ...
            // > **Interviewer:** ...
            // 
            // ðŸ’¡ **AI Hint:** ...

            for (const msg of messages) {
                const type = msg.message_type;
                const payload = msg.payload;
                const timestamp = new Date(msg.created_at).toLocaleTimeString();

                if (type === 'TRANSCRIPT_UPDATE') {
                    // payload usually contains { text: "...", isFinal: true/false }
                    // We only want to show final segments or significant chunks
                    if (payload && payload.text) {
                        // Clean up text
                        const text = payload.text.trim();
                        if (text.length > 5) { // partial filter
                            md += `**[${timestamp}] Transcript:** ${text}\n\n`;
                        }
                    }
                } else if (type === 'HINT_ADDED') {
                    // payload is { hint: "...", type: "explain"|"code"|etc }
                    if (payload && payload.hint) {
                        const hintType = payload.type ? payload.type.toUpperCase() : 'AI HINT';
                        md += `> ðŸ’¡ **${hintType}:**\n> ${payload.hint.replace(/\n/g, '\n> ')}\n\n`;
                    }
                } else if (type === 'SCREENSHOT_ADDED') {
                     md += `**[${timestamp}] ðŸ“¸ Screenshot Captured**\n\n`;
                }
            }

            md += `---\n`;
            md += `\n*Generated by Xtroone AI Interview Copilot*`;

            return md;

        } catch (error) {
            console.error('[ReportGenerator] Error generating report:', error);
            return `# Error Generating Report\n\n${error.message}`;
        }
    }
}
